# Shell function to send logs to Loki
# Minimal required env vars:
#   LOKI_URL (e.g. "https://monitor.lehel.xyz/loki/api/v1/push")
#   LOKI_API_KEY (X-Scope-OrgID header - acts as API key in multi-tenant mode)
# Optional:
#   LOKI_INSECURE=1          # if you need curl -k for self-signed certs
#   LOKI_DRY_RUN=1           # prints payload instead of sending (debug)
#   LOGDY_SILENT=1           # suppress console output
#   LOGDY_NO_COLOR=1         # disable ANSI colors in console output
#   LOGDY_LOKI_REQUIRED=1    # fail script if Loki unavailable (default: false)
#   LOGDY_ALSO_TO_FILE=/path # append to file in addition to console/Loki

# Defaults (override in environment)
: ${LOKI_INSECURE:=1}
: ${LOKI_TIMEOUT:=5}

LOKI__json_escape() {
  # argument -> escaped JSON-safe string on stdout
  local s="$1"
  s=${s//\\/\\\\}           # backslash
  s=${s//\"/\\\"}           # double quote
  s=${s//$'\n'/\\n}         # newline
  s=${s//$'\r'/\\r}         # carriage return
  printf '%s' "$s"
}

LOKI__get_color() {
  # Get ANSI color code for log level
  local level="$1"

  # If colors disabled or not a TTY, return empty
  if [[ "${LOGDY_NO_COLOR:-0}" -eq 1 ]] || ! [ -t 1 ]; then
    printf ''
    return
  fi

  case "$level" in
    error) printf '\033[0;31m' ;;  # Red
    warn)  printf '\033[1;33m' ;;  # Yellow
    info)  printf '\033[0;36m' ;;  # Cyan
    debug) printf '\033[0;90m' ;;  # Gray
    trace) printf '\033[2;90m' ;;  # Dim gray
    *)     printf '' ;;
  esac
}

LOKI__format_console() {
  # Format log message for console output
  local level="$1"
  local message="$2"
  shift 2

  local timestamp="$(date +'%Y-%m-%d %H:%M:%S')"
  local color="$(LOKI__get_color "$level")"
  local reset='\033[0m'

  # Build message with key=value pairs
  local full_msg="$message"
  if [[ $# -gt 0 ]]; then
    full_msg="$message"
    for arg in "$@"; do
      if [[ "$arg" == *=* ]]; then
        full_msg="$full_msg $arg"
      fi
    done
  fi

  if [[ -n "$color" ]]; then
    printf "${color}[%s] [%5s]${reset} %s\n" "$timestamp" "$level" "$full_msg"
  else
    printf "[%s] [%5s] %s\n" "$timestamp" "$level" "$full_msg"
  fi
}

logdy() {
  local level timestamp_ns host script user message json_line curl_opts body

  # quick validation
  if [[ -z "${LOKI_URL}" ]]; then
    printf '%s\n' "logdy: ERROR: please set LOKI_URL (e.g. https://monitor.lehel.xyz/loki/api/v1/push)" >&2
    return 2
  fi
  if [[ -z "${LOKI_API_KEY}" ]]; then
    printf '%s\n' "logdy: ERROR: please set LOKI_API_KEY (used as X-Scope-OrgID)" >&2
    return 2
  fi

  host="${LOKI_SOURCE:-$(hostname)}"
  script="${LOKI_SCRIPT_NAME:-${ZSH_SCRIPT:-$(basename "$0")}}"
  user="${USER:-$(whoami)}"

  # If first arg is -h/--help show usage
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    cat <<'USG' >&2
Usage:
  logdy [level] [message] [key=value ...]

Examples:
  logdy info "Backup completed"
  logdy warn "Disk nearly full" disk=/dev/sda1 usage=92%
  logdy error "Failed to connect"
  cat logfile | logdy warn -    # read message from stdin (use '-' as message)

Log Levels:
  info, warn, error, debug, trace (defaults to 'info' if not specified)

Output:
  - Console: Colored timestamped output to stdout (unless LOGDY_SILENT=1)
  - Loki: Structured JSON logs sent to remote Loki instance
  - File: Optional file output (set LOGDY_ALSO_TO_FILE=/path/to/file)

Environment Variables:
  LOGDY_SILENT=1          Suppress console output
  LOGDY_NO_COLOR=1        Disable ANSI colors
  LOGDY_LOKI_REQUIRED=1   Fail script if Loki unavailable (default: continue)
  LOGDY_ALSO_TO_FILE=path Append logs to file in addition to console/Loki

Loki Labels:
  job=shell, host=<hostname>, user=<username>, script=<script>, level=<level>
USG
    return 0
  fi

  # if first token is a known level, take it; otherwise default to info
  case "$1" in
    info|warn|error|debug|trace) level="$1"; shift ;;
    *) level="info" ;;
  esac

  # Timestamp in nanoseconds (Loki requirement)
  timestamp_ns="$(date +%s)000000000"

  # If there's at least one arg and the first arg is '-' -> read stdin as message
  if [[ "$1" == "-" ]]; then
    message="$(cat -)"
    shift
  elif [[ $# -eq 0 ]] && ! [ -t 0 ]; then
    # No args but stdin has data
    message="$(cat -)"
  else
    # Build message from non key=value args
    local message_parts=()
    while [[ $# -gt 0 ]]; do
      if [[ "$1" == *=* ]]; then
        break
      fi
      message_parts+=("$1")
      shift
    done
    if (( ${#message_parts} )); then
      message="$(printf '%s ' "${message_parts[@]}" | sed 's/ $//')"
    fi
  fi

  # Build JSON log line with message and any key=value pairs
  local escaped_msg
  escaped_msg="$(LOKI__json_escape "$message")"
  json_line="{\"level\":\"${level}\",\"host\":\"${host}\",\"user\":\"${user}\",\"script\":\"${script}\",\"msg\":\"${escaped_msg}\""

  # Add key=value pairs as JSON fields
  for arg in "$@"; do
    if [[ "$arg" == *=* ]]; then
      local k=${arg%%=*}
      local v=${arg#*=}
      v="$(LOKI__json_escape "$v")"
      json_line+=",\"$k\":\"$v\""
    fi
  done
  json_line+="}"

  # Console output (unless suppressed)
  if [[ "${LOGDY_SILENT:-0}" != "1" ]]; then
    # Collect original key=value args for console display
    local kvpairs=()
    for arg in "$@"; do
      if [[ "$arg" == *=* ]]; then
        kvpairs+=("$arg")
      fi
    done
    LOKI__format_console "$level" "$message" "${kvpairs[@]}"
  fi

  # Optional file output
  if [[ -n "${LOGDY_ALSO_TO_FILE}" ]]; then
    local timestamp_file="$(date +'%Y-%m-%d %H:%M:%S')"
    echo "[${timestamp_file}] [${level}] ${message}" >> "$LOGDY_ALSO_TO_FILE"
  fi

  # Escape json_line for embedding in outer JSON
  local escaped_json_line
  escaped_json_line="${json_line//\\/\\\\}"  # Escape backslashes first
  escaped_json_line="${escaped_json_line//\"/\\\"}"  # Escape quotes

  # Loki push API format
  # Labels identify the stream, log line is the value (now includes user)
  body="{\"streams\":[{\"stream\":{\"job\":\"shell\",\"host\":\"${host}\",\"user\":\"${user}\",\"script\":\"${script}\",\"level\":\"${level}\"},\"values\":[[\"${timestamp_ns}\",\"${escaped_json_line}\"]]}]}"

  # If dry-run, print payload and return
  if [[ "${LOKI_DRY_RUN:-0}" -eq 1 ]]; then
    printf '%s\n' "logdy (dry-run) payload:" >&2
    printf '%s\n' "$body" | jq . 2>/dev/null || printf '%s\n' "$body" >&2
    return 0
  fi

  # Curl options (timeout + optionally -k)
  curl_opts=( -s --max-time "${LOKI_TIMEOUT}" )
  if [[ "${LOKI_INSECURE:-0}" -eq 1 ]]; then
    curl_opts+=( -k )
  fi

  # Headers with API key (X-Scope-OrgID acts as API key in multi-tenant Loki)
  local headers=( -H "Content-Type: application/json" -H "X-Scope-OrgID: ${LOKI_API_KEY}" )

  # Send to Loki (temporarily disable set -e to handle curl errors gracefully)
  local http_code curl_code
  set +e  # Disable errexit temporarily
  http_code="$(curl "${curl_opts[@]}" -o /dev/null -w "%{http_code}" \
    -X POST "${LOKI_URL}" \
    "${headers[@]}" \
    --data "${body}" 2>/dev/null)"
  curl_code=$?
  set -e  # Re-enable errexit

  # Success: HTTP 204 (No Content) is expected from Loki
  if [[ $curl_code -eq 0 && ( "$http_code" == "204" || "$http_code" == "200" ) ]]; then
    return 0
  else
    # Loki failed - decide whether to fail script based on LOGDY_LOKI_REQUIRED
    if [[ "${LOGDY_LOKI_REQUIRED:-0}" -eq 1 ]]; then
      printf '%s\n' "logdy: ERROR: Loki required but unavailable (HTTP ${http_code}, curl exit ${curl_code})" >&2
      return 4
    else
      printf '%s\n' "logdy: warning: failed to send to Loki (HTTP ${http_code}, curl exit ${curl_code}) - continuing" >&2
      return 0
    fi
  fi
}

# Backwards compatibility alias
loki() { logdy "$@"; }
